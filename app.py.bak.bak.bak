# app.py
import asyncio
import logging
import os
import random
import struct

from pymodbus.datastore import (
    ModbusSlaveContext,
    ModbusServerContext,
    ModbusSequentialDataBlock,
)
from pymodbus.server.async_io import StartAsyncTcpServer

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("pymodbus")

# ---- Config via env (good defaults for Docker) ----
HOST   = os.getenv("HOST", "0.0.0.0")   # bind all interfaces
PORT   = int(os.getenv("PORT", "5020")) # your compose maps 5020:5020
UNIT   = int(os.getenv("UNIT_ID", "1"))

# Word order for 32-bit float (false = hi,lo; true = lo,hi)
SWAP_WORDS = os.getenv("SWAP_WORDS_FOR_FLOAT", "false").lower() in ("1", "true", "yes")

# Also write to the far-apart addresses you mapped as globals in OpenPLC
ENABLE_FAR = os.getenv("ENABLE_FAR_ADDRS", "true").lower() in ("1", "true", "yes")

# The small contiguous window OpenPLC can read in one block
BASE_START = int(os.getenv("BASE_START", "1148"))  # will write 1148..1151

def f32_to_words(val: float, swap: bool = False):
    """Convert a Python float to two Modbus 16-bit words (big-endian)."""
    b = struct.pack(">f", val)  # IEEE-754 big-endian
    hi = int.from_bytes(b[0:2], "big")
    lo = int.from_bytes(b[2:4], "big")
    return (lo, hi) if swap else (hi, lo)

def make_context() -> ModbusServerContext:
    """
    Map ONLY UNIT=1 explicitly (single=False) so unit-id matching is unambiguous.
    Provide a large Holding Register map to cover all addresses we touch.
    Tiny DI/CO/IR maps prevent IllegalAddress if a master probes them.
    zero_mode=True so address 1148 means 1148 (no -1 offset).
    """
    slave = ModbusSlaveContext(
        di=ModbusSequentialDataBlock(0, [0] * 1),
        co=ModbusSequentialDataBlock(0, [0] * 1),
        ir=ModbusSequentialDataBlock(0, [0] * 1),
        hr=ModbusSequentialDataBlock(0, [0] * 10000),
        zero_mode=True,
    )
    return ModbusServerContext(slaves={UNIT: slave}, single=False)

async def updater(ctx: ModbusServerContext):
    fc = 3  # Holding Registers (FC3)
    while True:
        # Contiguous block at 1148..1151
        a = BASE_START
        u16_a = random.randint(0, 65535)           # HR1148
        u16_b = random.randint(0, 65535)           # HR1149
        f32   = random.uniform(0.0, 100000.0)      # HR1150/1151
        hi, lo = f32_to_words(f32, SWAP_WORDS)

        ctx[UNIT].setValues(fc, a + 0, [u16_a])         # 1148
        ctx[UNIT].setValues(fc, a + 1, [u16_b])         # 1149
        ctx[UNIT].setValues(fc, a + 2, [hi, lo])        # 1150/1151

        if ENABLE_FAR:
            # Also write to your far globals:
            # 2305 (UINT16), and 4188/4189 (FLOAT32 split)
            u16_far = random.randint(0, 65535)
            f32_far = random.uniform(0.0, 100000.0)
            hi2, lo2 = f32_to_words(f32_far, SWAP_WORDS)
            ctx[UNIT].setValues(fc, 2305, [u16_far])    # 2305
            ctx[UNIT].setValues(fc, 4188, [hi2, lo2])   # 4188/4189

        logging.info(
            "HR%d=%d HR%d=%d HR%d/%d=float(%.3f)%s",
            a, u16_a, a+1, u16_b, a+2, a+3, f32,
            " +far" if ENABLE_FAR else "",
        )
        await asyncio.sleep(1.0)

async def main():
    ctx = make_context()
    server = asyncio.create_task(StartAsyncTcpServer(context=ctx, address=(HOST, PORT)))
    writer = asyncio.create_task(updater(ctx))
    await asyncio.gather(server, writer)

if __name__ == "__main__":
    asyncio.run(main())
