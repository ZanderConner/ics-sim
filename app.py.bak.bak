# app.py
import asyncio, logging, os, random, struct
from pymodbus.datastore import ModbusSlaveContext, ModbusServerContext, ModbusSequentialDataBlock
from pymodbus.server.async_io import StartAsyncTcpServer

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("pymodbus")

# ---- Config via env ----
HOST = os.getenv("HOST", "0.0.0.0")
PORT = int(os.getenv("PORT", "5020"))
UNIT_ID = int(os.getenv("UNIT_ID", "1"))

# OpenPLC one-block setup: Start=1148, Size=4
BASE_START = int(os.getenv("BASE_START", "1148"))   # 1148..1151
BASE_SIZE  = int(os.getenv("BASE_SIZE", "4"))

# Also write to far-apart addresses (2305 and 4188/4189)?
ENABLE_FAR_ADDRS = os.getenv("ENABLE_FAR_ADDRS", "false").lower() in ("1","true","yes")

# Float word order (set true if your PLC expects word-swapped floats)
SWAP_WORDS_FOR_FLOAT = os.getenv("SWAP_WORDS_FOR_FLOAT", "false").lower() in ("1","true","yes")

# Random ranges
U16_MIN = int(os.getenv("U16_MIN", "0"))
U16_MAX = int(os.getenv("U16_MAX", "65535"))
F32_MIN = float(os.getenv("F32_MIN", "0"))
F32_MAX = float(os.getenv("F32_MAX", "100000"))

def f32_to_words(val: float, swap_words: bool = False):
    b = struct.pack(">f", val)  # big-endian IEEE-754
    hi = int.from_bytes(b[0:2], "big")
    lo = int.from_bytes(b[2:4], "big")
    return (lo, hi) if swap_words else (hi, lo)

def make_context():
    # Big HR map so any address we touch exists; tiny DI/CO/IR so FC2/FC4 don't IllegalAddress.
    return ModbusServerContext(
        slaves=ModbusSlaveContext(
            di=ModbusSequentialDataBlock(0, [0]*1),
            co=ModbusSequentialDataBlock(0, [0]*1),
            ir=ModbusSequentialDataBlock(0, [0]*1),
            hr=ModbusSequentialDataBlock(0, [0]*10000),
            zero_mode=True,  # address 1148 means 1148 (no -1)
        ),
        single=True
    )

async def updater(ctx: ModbusServerContext):
    fc = 3  # Holding Registers
    while True:
        # ---- Contiguous block (1148..1151 by default) ----
        a = BASE_START
        u16_a = random.randint(U16_MIN, U16_MAX)
        u16_b = random.randint(U16_MIN, U16_MAX)
        f32   = random.uniform(F32_MIN, F32_MAX)
        hi, lo = f32_to_words(f32, SWAP_WORDS_FOR_FLOAT)

        ctx[UNIT_ID].setValues(fc, a + 0, [u16_a])     # 1148
        ctx[UNIT_ID].setValues(fc, a + 1, [u16_b])     # 1149
        ctx[UNIT_ID].setValues(fc, a + 2, [hi, lo])    # 1150/1151

        # ---- Optional: also write to far-apart addresses ----
        if ENABLE_FAR_ADDRS:
            u16_far = random.randint(U16_MIN, U16_MAX)
            f32_far = random.uniform(F32_MIN, F32_MAX)
            hi2, lo2 = f32_to_words(f32_far, SWAP_WORDS_FOR_FLOAT)
            ctx[UNIT_ID].setValues(fc, 2305, [u16_far])      # 2305
            ctx[UNIT_ID].setValues(fc, 4188, [hi2, lo2])     # 4188/4189

        log.info("HR%d=%d HR%d=%d HR%d/%d=float(%.3f)%s",
                 a, u16_a, a+1, u16_b, a+2, a+3, f32,
                 " +far" if ENABLE_FAR_ADDRS else "")
        await asyncio.sleep(1.0)

async def main():
    ctx = make_context()
    server = asyncio.create_task(StartAsyncTcpServer(context=ctx, address=(HOST, PORT)))
    updates = asyncio.create_task(updater(ctx))
    await asyncio.gather(server, updates)

if __name__ == "__main__":
    asyncio.run(main())
