import asyncio
import os
import random
import struct
from typing import Tuple

from pymodbus.datastore import (
    ModbusServerContext, ModbusSlaveContext, ModbusSequentialDataBlock
)
from pymodbus.server.async_io import StartAsyncTcpServer

HOST = os.getenv("HOST", "0.0.0.0")
PORT = int(os.getenv("PORT", "5020"))
UNIT_ID = int(os.getenv("UNIT_ID", "1"))

def u32_to_words(val: int) -> Tuple[int, int]:
    return (val >> 16) & 0xFFFF, val & 0xFFFF

def f32_to_words(val: float) -> Tuple[int, int]:
    as_u32 = struct.unpack(">I", struct.pack(">f", float(val)))[0]
    return u32_to_words(as_u32)

def set_u16(ctx: ModbusServerContext, addr: int, val: int):
    ctx[UNIT_ID].setValues(3, addr, [val & 0xFFFF])

def set_u32(ctx: ModbusServerContext, addr: int, val: int):
    hi, lo = u32_to_words(val & 0xFFFFFFFF)
    ctx[UNIT_ID].setValues(3, addr, [hi, lo])

def set_f32(ctx: ModbusServerContext, addr: int, val: float):
    hi, lo = f32_to_words(val)
    ctx[UNIT_ID].setValues(3, addr, [hi, lo])

def build_context() -> ModbusServerContext:
    size = 5000
    store = ModbusSlaveContext(
        di=ModbusSequentialDataBlock(0, [0]*1),
        co=ModbusSequentialDataBlock(0, [0]*1),
        hr=ModbusSequentialDataBlock(0, [0]*size),
        ir=ModbusSequentialDataBlock(0, [0]*1),
        zero_mode=True,
    )
    return ModbusServerContext(slaves={UNIT_ID: store}, single=False)

async def updater(ctx: ModbusServerContext):
    count = 0
    while True:
        count = (count % 4) + 1
        set_u16(ctx, 1148, 32117)
        set_u16(ctx, 2305, 50 + count)
        set_u16(ctx, 2306, random.randint(45, 55))
        set_u32(ctx, 3188, 32514)
        set_u32(ctx, 3876, 50000 + count)
        set_u32(ctx, 3878, random.randint(45000, 55000))
        set_f32(ctx, 4188, 32514.2)
        set_f32(ctx, 4876, 50000.0 + count)
        set_f32(ctx, 4878, random.uniform(45000.0, 55000.0))
        await asyncio.sleep(1.0)

async def main():
    context = build_context()
    server_task = asyncio.create_task(
        StartAsyncTcpServer(context=context, address=(HOST, PORT))
    )
    update_task = asyncio.create_task(updater(context))
    await asyncio.gather(server_task, update_task)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        pass
